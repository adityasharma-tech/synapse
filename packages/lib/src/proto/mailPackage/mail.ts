// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.21.12
// source: packages/lib/src/proto/mailPackage/mail.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
    type CallOptions,
    ChannelCredentials,
    Client,
    type ClientOptions,
    type ClientUnaryCall,
    type handleUnaryCall,
    makeGenericClientConstructor,
    Metadata,
    type ServiceError,
    type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "mailPackage";

export interface DefaultMailRequest {
    email: string;
    token: string;
}

export interface DefaultMailResponse {
    success: boolean;
    error: string;
}

function createBaseDefaultMailRequest(): DefaultMailRequest {
    return { email: "", token: "" };
}

export const DefaultMailRequest: MessageFns<DefaultMailRequest> = {
    encode(
        message: DefaultMailRequest,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.email !== "") {
            writer.uint32(10).string(message.email);
        }
        if (message.token !== "") {
            writer.uint32(18).string(message.token);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): DefaultMailRequest {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDefaultMailRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.email = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.token = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): DefaultMailRequest {
        return {
            email: isSet(object.email) ? globalThis.String(object.email) : "",
            token: isSet(object.token) ? globalThis.String(object.token) : "",
        };
    },

    toJSON(message: DefaultMailRequest): unknown {
        const obj: any = {};
        if (message.email !== "") {
            obj.email = message.email;
        }
        if (message.token !== "") {
            obj.token = message.token;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<DefaultMailRequest>, I>>(
        base?: I
    ): DefaultMailRequest {
        return DefaultMailRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DefaultMailRequest>, I>>(
        object: I
    ): DefaultMailRequest {
        const message = createBaseDefaultMailRequest();
        message.email = object.email ?? "";
        message.token = object.token ?? "";
        return message;
    },
};

function createBaseDefaultMailResponse(): DefaultMailResponse {
    return { success: false, error: "" };
}

export const DefaultMailResponse: MessageFns<DefaultMailResponse> = {
    encode(
        message: DefaultMailResponse,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): DefaultMailResponse {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDefaultMailResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.success = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): DefaultMailResponse {
        return {
            success: isSet(object.success)
                ? globalThis.Boolean(object.success)
                : false,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },

    toJSON(message: DefaultMailResponse): unknown {
        const obj: any = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<DefaultMailResponse>, I>>(
        base?: I
    ): DefaultMailResponse {
        return DefaultMailResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DefaultMailResponse>, I>>(
        object: I
    ): DefaultMailResponse {
        const message = createBaseDefaultMailResponse();
        message.success = object.success ?? false;
        message.error = object.error ?? "";
        return message;
    },
};

export type MailService = typeof MailService;
export const MailService = {
    sendSignupConfirmMail: {
        path: "/mailPackage.Mail/SendSignupConfirmMail",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DefaultMailRequest) =>
            Buffer.from(DefaultMailRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DefaultMailRequest.decode(value),
        responseSerialize: (value: DefaultMailResponse) =>
            Buffer.from(DefaultMailResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            DefaultMailResponse.decode(value),
    },
    sendResetPasswordMail: {
        path: "/mailPackage.Mail/SendResetPasswordMail",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DefaultMailRequest) =>
            Buffer.from(DefaultMailRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DefaultMailRequest.decode(value),
        responseSerialize: (value: DefaultMailResponse) =>
            Buffer.from(DefaultMailResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            DefaultMailResponse.decode(value),
    },
} as const;

export interface MailServer extends UntypedServiceImplementation {
    sendSignupConfirmMail: handleUnaryCall<
        DefaultMailRequest,
        DefaultMailResponse
    >;
    sendResetPasswordMail: handleUnaryCall<
        DefaultMailRequest,
        DefaultMailResponse
    >;
}

export interface MailClient extends Client {
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
}

export const MailClient = makeGenericClientConstructor(
    MailService,
    "mailPackage.Mail"
) as unknown as {
    new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ClientOptions>
    ): MailClient;
    service: typeof MailService;
    serviceName: string;
};

type Builtin =
    | Date
    | Function
    | Uint8Array
    | string
    | number
    | boolean
    | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
          [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
      };

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
