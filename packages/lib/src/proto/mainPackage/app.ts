// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.21.12
// source: packages/lib/src/proto/mainPackage/app.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
    type CallOptions,
    ChannelCredentials,
    Client,
    type ClientOptions,
    type ClientUnaryCall,
    type handleUnaryCall,
    makeGenericClientConstructor,
    Metadata,
    type ServiceError,
    type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "mainPackage";

export interface DefaultMailRequest {
    email: string;
    token: string;
}

export interface DefaultMailResponse {
    success: boolean;
    error: string;
}

export interface HasPermissionRequest {
    user: number;
    resource: string;
    effect: string;
    action: string[];
}

export interface HasPermissionResponse {
    allowed: boolean;
}

export interface InsertTupleRequest {
    user: number;
    resource: string;
    effect: string;
    action: string;
}

export interface InsertTupleResponse {
    success: boolean;
}

function createBaseDefaultMailRequest(): DefaultMailRequest {
    return { email: "", token: "" };
}

export const DefaultMailRequest: MessageFns<DefaultMailRequest> = {
    encode(
        message: DefaultMailRequest,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.email !== "") {
            writer.uint32(10).string(message.email);
        }
        if (message.token !== "") {
            writer.uint32(18).string(message.token);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): DefaultMailRequest {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDefaultMailRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.email = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.token = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): DefaultMailRequest {
        return {
            email: isSet(object.email) ? globalThis.String(object.email) : "",
            token: isSet(object.token) ? globalThis.String(object.token) : "",
        };
    },

    toJSON(message: DefaultMailRequest): unknown {
        const obj: any = {};
        if (message.email !== "") {
            obj.email = message.email;
        }
        if (message.token !== "") {
            obj.token = message.token;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<DefaultMailRequest>, I>>(
        base?: I
    ): DefaultMailRequest {
        return DefaultMailRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DefaultMailRequest>, I>>(
        object: I
    ): DefaultMailRequest {
        const message = createBaseDefaultMailRequest();
        message.email = object.email ?? "";
        message.token = object.token ?? "";
        return message;
    },
};

function createBaseDefaultMailResponse(): DefaultMailResponse {
    return { success: false, error: "" };
}

export const DefaultMailResponse: MessageFns<DefaultMailResponse> = {
    encode(
        message: DefaultMailResponse,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): DefaultMailResponse {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDefaultMailResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.success = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): DefaultMailResponse {
        return {
            success: isSet(object.success)
                ? globalThis.Boolean(object.success)
                : false,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },

    toJSON(message: DefaultMailResponse): unknown {
        const obj: any = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<DefaultMailResponse>, I>>(
        base?: I
    ): DefaultMailResponse {
        return DefaultMailResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DefaultMailResponse>, I>>(
        object: I
    ): DefaultMailResponse {
        const message = createBaseDefaultMailResponse();
        message.success = object.success ?? false;
        message.error = object.error ?? "";
        return message;
    },
};

function createBaseHasPermissionRequest(): HasPermissionRequest {
    return { user: 0, resource: "", effect: "", action: [] };
}

export const HasPermissionRequest: MessageFns<HasPermissionRequest> = {
    encode(
        message: HasPermissionRequest,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.user !== 0) {
            writer.uint32(16).int64(message.user);
        }
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        if (message.effect !== "") {
            writer.uint32(26).string(message.effect);
        }
        for (const v of message.action) {
            writer.uint32(34).string(v!);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): HasPermissionRequest {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHasPermissionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 16) {
                        break;
                    }

                    message.user = longToNumber(reader.int64());
                    continue;
                }
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.resource = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.effect = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }

                    message.action.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): HasPermissionRequest {
        return {
            user: isSet(object.user) ? globalThis.Number(object.user) : 0,
            resource: isSet(object.resource)
                ? globalThis.String(object.resource)
                : "",
            effect: isSet(object.effect)
                ? globalThis.String(object.effect)
                : "",
            action: globalThis.Array.isArray(object?.action)
                ? object.action.map((e: any) => globalThis.String(e))
                : [],
        };
    },

    toJSON(message: HasPermissionRequest): unknown {
        const obj: any = {};
        if (message.user !== 0) {
            obj.user = Math.round(message.user);
        }
        if (message.resource !== "") {
            obj.resource = message.resource;
        }
        if (message.effect !== "") {
            obj.effect = message.effect;
        }
        if (message.action?.length) {
            obj.action = message.action;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<HasPermissionRequest>, I>>(
        base?: I
    ): HasPermissionRequest {
        return HasPermissionRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<HasPermissionRequest>, I>>(
        object: I
    ): HasPermissionRequest {
        const message = createBaseHasPermissionRequest();
        message.user = object.user ?? 0;
        message.resource = object.resource ?? "";
        message.effect = object.effect ?? "";
        message.action = object.action?.map((e) => e) || [];
        return message;
    },
};

function createBaseHasPermissionResponse(): HasPermissionResponse {
    return { allowed: false };
}

export const HasPermissionResponse: MessageFns<HasPermissionResponse> = {
    encode(
        message: HasPermissionResponse,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.allowed !== false) {
            writer.uint32(8).bool(message.allowed);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): HasPermissionResponse {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHasPermissionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.allowed = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): HasPermissionResponse {
        return {
            allowed: isSet(object.allowed)
                ? globalThis.Boolean(object.allowed)
                : false,
        };
    },

    toJSON(message: HasPermissionResponse): unknown {
        const obj: any = {};
        if (message.allowed !== false) {
            obj.allowed = message.allowed;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<HasPermissionResponse>, I>>(
        base?: I
    ): HasPermissionResponse {
        return HasPermissionResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<HasPermissionResponse>, I>>(
        object: I
    ): HasPermissionResponse {
        const message = createBaseHasPermissionResponse();
        message.allowed = object.allowed ?? false;
        return message;
    },
};

function createBaseInsertTupleRequest(): InsertTupleRequest {
    return { user: 0, resource: "", effect: "", action: "" };
}

export const InsertTupleRequest: MessageFns<InsertTupleRequest> = {
    encode(
        message: InsertTupleRequest,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.user !== 0) {
            writer.uint32(8).int64(message.user);
        }
        if (message.resource !== "") {
            writer.uint32(18).string(message.resource);
        }
        if (message.effect !== "") {
            writer.uint32(26).string(message.effect);
        }
        if (message.action !== "") {
            writer.uint32(34).string(message.action);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): InsertTupleRequest {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInsertTupleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.user = longToNumber(reader.int64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.resource = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.effect = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }

                    message.action = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): InsertTupleRequest {
        return {
            user: isSet(object.user) ? globalThis.Number(object.user) : 0,
            resource: isSet(object.resource)
                ? globalThis.String(object.resource)
                : "",
            effect: isSet(object.effect)
                ? globalThis.String(object.effect)
                : "",
            action: isSet(object.action)
                ? globalThis.String(object.action)
                : "",
        };
    },

    toJSON(message: InsertTupleRequest): unknown {
        const obj: any = {};
        if (message.user !== 0) {
            obj.user = Math.round(message.user);
        }
        if (message.resource !== "") {
            obj.resource = message.resource;
        }
        if (message.effect !== "") {
            obj.effect = message.effect;
        }
        if (message.action !== "") {
            obj.action = message.action;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<InsertTupleRequest>, I>>(
        base?: I
    ): InsertTupleRequest {
        return InsertTupleRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<InsertTupleRequest>, I>>(
        object: I
    ): InsertTupleRequest {
        const message = createBaseInsertTupleRequest();
        message.user = object.user ?? 0;
        message.resource = object.resource ?? "";
        message.effect = object.effect ?? "";
        message.action = object.action ?? "";
        return message;
    },
};

function createBaseInsertTupleResponse(): InsertTupleResponse {
    return { success: false };
}

export const InsertTupleResponse: MessageFns<InsertTupleResponse> = {
    encode(
        message: InsertTupleResponse,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        return writer;
    },

    decode(
        input: BinaryReader | Uint8Array,
        length?: number
    ): InsertTupleResponse {
        const reader =
            input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInsertTupleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.success = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): InsertTupleResponse {
        return {
            success: isSet(object.success)
                ? globalThis.Boolean(object.success)
                : false,
        };
    },

    toJSON(message: InsertTupleResponse): unknown {
        const obj: any = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<InsertTupleResponse>, I>>(
        base?: I
    ): InsertTupleResponse {
        return InsertTupleResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<InsertTupleResponse>, I>>(
        object: I
    ): InsertTupleResponse {
        const message = createBaseInsertTupleResponse();
        message.success = object.success ?? false;
        return message;
    },
};

export type MailService = typeof MailService;
export const MailService = {
    sendSignupConfirmMail: {
        path: "/mainPackage.Mail/SendSignupConfirmMail",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DefaultMailRequest) =>
            Buffer.from(DefaultMailRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DefaultMailRequest.decode(value),
        responseSerialize: (value: DefaultMailResponse) =>
            Buffer.from(DefaultMailResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            DefaultMailResponse.decode(value),
    },
    sendResetPasswordMail: {
        path: "/mainPackage.Mail/SendResetPasswordMail",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DefaultMailRequest) =>
            Buffer.from(DefaultMailRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DefaultMailRequest.decode(value),
        responseSerialize: (value: DefaultMailResponse) =>
            Buffer.from(DefaultMailResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            DefaultMailResponse.decode(value),
    },
} as const;

export interface MailServer extends UntypedServiceImplementation {
    sendSignupConfirmMail: handleUnaryCall<
        DefaultMailRequest,
        DefaultMailResponse
    >;
    sendResetPasswordMail: handleUnaryCall<
        DefaultMailRequest,
        DefaultMailResponse
    >;
}

export interface MailClient extends Client {
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendSignupConfirmMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
    sendResetPasswordMail(
        request: DefaultMailRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: DefaultMailResponse
        ) => void
    ): ClientUnaryCall;
}

export const MailClient = makeGenericClientConstructor(
    MailService,
    "mainPackage.Mail"
) as unknown as {
    new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ClientOptions>
    ): MailClient;
    service: typeof MailService;
    serviceName: string;
};

export type PermitService = typeof PermitService;
export const PermitService = {
    hasPermission: {
        path: "/mainPackage.Permit/HasPermission",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: HasPermissionRequest) =>
            Buffer.from(HasPermissionRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) =>
            HasPermissionRequest.decode(value),
        responseSerialize: (value: HasPermissionResponse) =>
            Buffer.from(HasPermissionResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            HasPermissionResponse.decode(value),
    },
    insertTuple: {
        path: "/mainPackage.Permit/InsertTuple",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: InsertTupleRequest) =>
            Buffer.from(InsertTupleRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => InsertTupleRequest.decode(value),
        responseSerialize: (value: InsertTupleResponse) =>
            Buffer.from(InsertTupleResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            InsertTupleResponse.decode(value),
    },
    removeTuple: {
        path: "/mainPackage.Permit/RemoveTuple",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: InsertTupleRequest) =>
            Buffer.from(InsertTupleRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => InsertTupleRequest.decode(value),
        responseSerialize: (value: InsertTupleResponse) =>
            Buffer.from(InsertTupleResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            InsertTupleResponse.decode(value),
    },
} as const;

export interface PermitServer extends UntypedServiceImplementation {
    hasPermission: handleUnaryCall<HasPermissionRequest, HasPermissionResponse>;
    insertTuple: handleUnaryCall<InsertTupleRequest, InsertTupleResponse>;
    removeTuple: handleUnaryCall<InsertTupleRequest, InsertTupleResponse>;
}

export interface PermitClient extends Client {
    hasPermission(
        request: HasPermissionRequest,
        callback: (
            error: ServiceError | null,
            response: HasPermissionResponse
        ) => void
    ): ClientUnaryCall;
    hasPermission(
        request: HasPermissionRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: HasPermissionResponse
        ) => void
    ): ClientUnaryCall;
    hasPermission(
        request: HasPermissionRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: HasPermissionResponse
        ) => void
    ): ClientUnaryCall;
    insertTuple(
        request: InsertTupleRequest,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
    insertTuple(
        request: InsertTupleRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
    insertTuple(
        request: InsertTupleRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
    removeTuple(
        request: InsertTupleRequest,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
    removeTuple(
        request: InsertTupleRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
    removeTuple(
        request: InsertTupleRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: InsertTupleResponse
        ) => void
    ): ClientUnaryCall;
}

export const PermitClient = makeGenericClientConstructor(
    PermitService,
    "mainPackage.Permit"
) as unknown as {
    new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ClientOptions>
    ): PermitClient;
    service: typeof PermitService;
    serviceName: string;
};

type Builtin =
    | Date
    | Function
    | Uint8Array
    | string
    | number
    | boolean
    | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
          [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
      };

function longToNumber(int64: { toString(): string }): number {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error(
            "Value is larger than Number.MAX_SAFE_INTEGER"
        );
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error(
            "Value is smaller than Number.MIN_SAFE_INTEGER"
        );
    }
    return num;
}

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
